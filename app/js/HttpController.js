// Generated by CoffeeScript 1.12.4
(function() {
  var DiffManager, HealthChecker, HttpController, PackManager, RestoreManager, UpdatesManager, _, logger;

  UpdatesManager = require("./UpdatesManager");

  DiffManager = require("./DiffManager");

  PackManager = require("./PackManager");

  RestoreManager = require("./RestoreManager");

  logger = require("logger-sharelatex");

  HealthChecker = require("./HealthChecker");

  _ = require("underscore");

  module.exports = HttpController = {
    flushDoc: function(req, res, next) {
      var doc_id, project_id;
      if (next == null) {
        next = function(error) {};
      }
      doc_id = req.params.doc_id;
      project_id = req.params.project_id;
      logger.log({
        project_id: project_id,
        doc_id: doc_id
      }, "compressing doc history");
      return UpdatesManager.processUncompressedUpdatesWithLock(project_id, doc_id, function(error) {
        if (error != null) {
          return next(error);
        }
        return res.send(204);
      });
    },
    flushProject: function(req, res, next) {
      var project_id;
      if (next == null) {
        next = function(error) {};
      }
      project_id = req.params.project_id;
      logger.log({
        project_id: project_id
      }, "compressing project history");
      return UpdatesManager.processUncompressedUpdatesForProject(project_id, function(error) {
        if (error != null) {
          return next(error);
        }
        return res.send(204);
      });
    },
    flushAll: function(req, res, next) {
      var limit;
      if (next == null) {
        next = function(error) {};
      }
      limit = req.query.limit != null ? parseInt(req.query.limit, 10) : -1;
      logger.log({
        limit: limit
      }, "flushing all projects");
      return UpdatesManager.flushAll(limit, function(error, result) {
        var all, failed, status, succeeded;
        if (error != null) {
          return next(error);
        }
        failed = result.failed, succeeded = result.succeeded, all = result.all;
        status = succeeded.length + " succeeded, " + failed.length + " failed";
        if (limit === 0) {
          return res.status(200).send(status + "\nwould flush:\n" + (all.join('\n')) + "\n");
        } else if (failed.length > 0) {
          logger.log({
            failed: failed,
            succeeded: succeeded
          }, "error flushing projects");
          return res.status(500).send(status + "\nfailed to flush:\n" + (failed.join('\n')) + "\n");
        } else {
          return res.status(200).send(status + "\nflushed " + succeeded.length + " projects of " + all.length + "\n");
        }
      });
    },
    checkDanglingUpdates: function(req, res, next) {
      if (next == null) {
        next = function(error) {};
      }
      logger.log("checking dangling updates");
      return UpdatesManager.getDanglingUpdates(function(error, result) {
        if (error != null) {
          return next(error);
        }
        if (result.length > 0) {
          logger.log({
            dangling: result
          }, "found dangling updates");
          return res.status(500).send("dangling updates:\n" + (result.join('\n')) + "\n");
        } else {
          return res.status(200).send("no dangling updates found\n");
        }
      });
    },
    checkDoc: function(req, res, next) {
      var doc_id, project_id;
      if (next == null) {
        next = function(error) {};
      }
      doc_id = req.params.doc_id;
      project_id = req.params.project_id;
      logger.log({
        project_id: project_id,
        doc_id: doc_id
      }, "checking doc history");
      return DiffManager.getDocumentBeforeVersion(project_id, doc_id, 1, function(error, document, rewoundUpdates) {
        var broken, i, j, len, len1, op, ref, update;
        if (error != null) {
          return next(error);
        }
        broken = [];
        for (i = 0, len = rewoundUpdates.length; i < len; i++) {
          update = rewoundUpdates[i];
          ref = update.op;
          for (j = 0, len1 = ref.length; j < len1; j++) {
            op = ref[j];
            if (op.broken === true) {
              broken.push(op);
            }
          }
        }
        if (broken.length > 0) {
          return res.send(broken);
        } else {
          return res.send(204);
        }
      });
    },
    getDiff: function(req, res, next) {
      var doc_id, from, project_id, to;
      if (next == null) {
        next = function(error) {};
      }
      doc_id = req.params.doc_id;
      project_id = req.params.project_id;
      if (req.query.from != null) {
        from = parseInt(req.query.from, 10);
      } else {
        from = null;
      }
      if (req.query.to != null) {
        to = parseInt(req.query.to, 10);
      } else {
        to = null;
      }
      logger.log({
        project_id: project_id,
        doc_id: doc_id,
        from: from,
        to: to
      }, "getting diff");
      return DiffManager.getDiff(project_id, doc_id, from, to, function(error, diff) {
        if (error != null) {
          return next(error);
        }
        return res.json({
          diff: diff
        });
      });
    },
    getUpdates: function(req, res, next) {
      var before, min_count, project_id;
      if (next == null) {
        next = function(error) {};
      }
      project_id = req.params.project_id;
      if (req.query.before != null) {
        before = parseInt(req.query.before, 10);
      }
      if (req.query.min_count != null) {
        min_count = parseInt(req.query.min_count, 10);
      }
      return UpdatesManager.getSummarizedProjectUpdates(project_id, {
        before: before,
        min_count: min_count
      }, function(error, updates, nextBeforeTimestamp) {
        if (error != null) {
          return next(error);
        }
        return res.json({
          updates: updates,
          nextBeforeTimestamp: nextBeforeTimestamp
        });
      });
    },
    restore: function(req, res, next) {
      var doc_id, project_id, ref, user_id, version;
      if (next == null) {
        next = function(error) {};
      }
      ref = req.params, doc_id = ref.doc_id, project_id = ref.project_id, version = ref.version;
      user_id = req.headers["x-user-id"];
      version = parseInt(version, 10);
      return RestoreManager.restoreToBeforeVersion(project_id, doc_id, version, user_id, function(error) {
        if (error != null) {
          return next(error);
        }
        return res.send(204);
      });
    },
    pushDocHistory: function(req, res, next) {
      var doc_id, project_id;
      if (next == null) {
        next = function(error) {};
      }
      project_id = req.params.project_id;
      doc_id = req.params.doc_id;
      logger.log({
        project_id: project_id,
        doc_id: doc_id
      }, "pushing all finalised changes to s3");
      return PackManager.pushOldPacks(project_id, doc_id, function(error) {
        if (error != null) {
          return next(error);
        }
        return res.send(204);
      });
    },
    pullDocHistory: function(req, res, next) {
      var doc_id, project_id;
      if (next == null) {
        next = function(error) {};
      }
      project_id = req.params.project_id;
      doc_id = req.params.doc_id;
      logger.log({
        project_id: project_id,
        doc_id: doc_id
      }, "pulling all packs from s3");
      return PackManager.pullOldPacks(project_id, doc_id, function(error) {
        if (error != null) {
          return next(error);
        }
        return res.send(204);
      });
    },
    healthCheck: function(req, res) {
      return HealthChecker.check(function(err) {
        if (err != null) {
          logger.err({
            err: err
          }, "error performing health check");
          return res.send(500);
        } else {
          return res.send(200);
        }
      });
    },
    checkLock: function(req, res) {
      return HealthChecker.checkLock(function(err) {
        if (err != null) {
          logger.err({
            err: err
          }, "error performing lock check");
          return res.send(500);
        } else {
          return res.send(200);
        }
      });
    }
  };

}).call(this);

//# sourceMappingURL=HttpController.js.map
