// Generated by CoffeeScript 1.12.4
(function() {
  var LockManager, MongoManager, PackManager, RedisManager, Settings, UpdateCompressor, UpdateTrimmer, UpdatesManager, WebApiManager, _, async, fiveMinutes, keys, logger;

  MongoManager = require("./MongoManager");

  PackManager = require("./PackManager");

  RedisManager = require("./RedisManager");

  UpdateCompressor = require("./UpdateCompressor");

  LockManager = require("./LockManager");

  WebApiManager = require("./WebApiManager");

  UpdateTrimmer = require("./UpdateTrimmer");

  logger = require("logger-sharelatex");

  async = require("async");

  _ = require("underscore");

  Settings = require("settings-sharelatex");

  keys = Settings.redis.lock.key_schema;

  module.exports = UpdatesManager = {
    compressAndSaveRawUpdates: function(project_id, doc_id, rawUpdates, temporary, callback) {
      var i, j, len, length, op, prevVersion, ref, thisVersion;
      if (callback == null) {
        callback = function(error) {};
      }
      length = rawUpdates.length;
      if (length === 0) {
        return callback();
      }
      for (i = j = 0, len = rawUpdates.length; j < len; i = ++j) {
        op = rawUpdates[i];
        if (!(i > 0)) {
          continue;
        }
        thisVersion = op != null ? op.v : void 0;
        prevVersion = (ref = rawUpdates[i - 1]) != null ? ref.v : void 0;
        if (!(prevVersion < thisVersion)) {
          logger.error({
            project_id: project_id,
            doc_id: doc_id,
            rawUpdates: rawUpdates,
            temporary: temporary,
            thisVersion: thisVersion,
            prevVersion: prevVersion
          }, "op versions out of order");
        }
      }
      return MongoManager.peekLastCompressedUpdate(doc_id, function(error, lastCompressedUpdate, lastVersion) {
        var REJECT_LARGE_OP_SIZE, compressedUpdates, discardedUpdates, k, last_timestamp, len1, opSizes, rawUpdate, ref1, ref2, size, ts;
        if (error != null) {
          return callback(error);
        }
        if (lastVersion != null) {
          discardedUpdates = [];
          rawUpdates = rawUpdates.slice(0);
          while ((rawUpdates[0] != null) && rawUpdates[0].v <= lastVersion) {
            discardedUpdates.push(rawUpdates.shift());
          }
          if (discardedUpdates.length) {
            logger.error({
              project_id: project_id,
              doc_id: doc_id,
              discardedUpdates: discardedUpdates,
              temporary: temporary,
              lastVersion: lastVersion
            }, "discarded updates already present");
          }
          if ((rawUpdates[0] != null) && rawUpdates[0].v !== lastVersion + 1) {
            ts = lastCompressedUpdate != null ? (ref1 = lastCompressedUpdate.meta) != null ? ref1.end_ts : void 0 : void 0;
            last_timestamp = ts != null ? new Date(ts) : 'unknown time';
            error = new Error("Tried to apply raw op at version " + rawUpdates[0].v + " to last compressed update with version " + lastVersion + " from " + last_timestamp);
            logger.error({
              err: error,
              doc_id: doc_id,
              project_id: project_id,
              prev_end_ts: ts,
              temporary: temporary,
              lastCompressedUpdate: lastCompressedUpdate
            }, "inconsistent doc versions");
            if (((ref2 = Settings.trackchanges) != null ? ref2.continueOnError : void 0) && rawUpdates[0].v > lastVersion + 1) {
              lastCompressedUpdate = null;
            } else {
              return callback(error);
            }
          }
        }
        if (rawUpdates.length === 0) {
          return callback();
        }
        REJECT_LARGE_OP_SIZE = 4 * 1024 * 1024;
        for (k = 0, len1 = rawUpdates.length; k < len1; k++) {
          rawUpdate = rawUpdates[k];
          opSizes = (function() {
            var l, len2, ref3, ref4, ref5, results1;
            ref3 = (rawUpdate != null ? rawUpdate.op : void 0) || [];
            results1 = [];
            for (l = 0, len2 = ref3.length; l < len2; l++) {
              op = ref3[l];
              results1.push(((ref4 = op.i) != null ? ref4.length : void 0) || ((ref5 = op.d) != null ? ref5.length : void 0));
            }
            return results1;
          })();
          size = _.max(opSizes);
          if (size > REJECT_LARGE_OP_SIZE) {
            error = new Error("dropped op exceeding maximum allowed size of " + REJECT_LARGE_OP_SIZE);
            logger.error({
              err: error,
              doc_id: doc_id,
              project_id: project_id,
              size: size,
              rawUpdate: rawUpdate
            }, "dropped op - too big");
            rawUpdate.op = [];
          }
        }
        compressedUpdates = UpdateCompressor.compressRawUpdates(null, rawUpdates);
        return PackManager.insertCompressedUpdates(project_id, doc_id, lastCompressedUpdate, compressedUpdates, temporary, function(error, result) {
          if (error != null) {
            return callback(error);
          }
          if (result != null) {
            logger.log({
              project_id: project_id,
              doc_id: doc_id,
              orig_v: lastCompressedUpdate != null ? lastCompressedUpdate.v : void 0,
              new_v: result.v
            }, "inserted updates into pack");
          }
          return callback();
        });
      });
    },
    _prepareProjectForUpdates: function(project_id, callback) {
      if (callback == null) {
        callback = function(error, temporary) {};
      }
      return UpdateTrimmer.shouldTrimUpdates(project_id, function(error, temporary) {
        if (error != null) {
          return callback(error);
        }
        return callback(null, temporary);
      });
    },
    _prepareDocForUpdates: function(project_id, doc_id, callback) {
      if (callback == null) {
        callback = function(error) {};
      }
      return MongoManager.backportProjectId(project_id, doc_id, function(error) {
        if (error != null) {
          return callback(error);
        }
        return callback(null);
      });
    },
    REDIS_READ_BATCH_SIZE: 100,
    processUncompressedUpdates: function(project_id, doc_id, temporary, callback) {
      if (callback == null) {
        callback = function(error) {};
      }
      return RedisManager.getOldestDocUpdates(doc_id, UpdatesManager.REDIS_READ_BATCH_SIZE, function(error, docUpdates) {
        var length;
        if (error != null) {
          return callback(error);
        }
        length = docUpdates.length;
        return RedisManager.expandDocUpdates(docUpdates, function(error, rawUpdates) {
          if (error != null) {
            logger.err({
              project_id: project_id,
              doc_id: doc_id,
              docUpdates: docUpdates
            }, "failed to parse docUpdates");
            return callback(error);
          }
          logger.log({
            project_id: project_id,
            doc_id: doc_id,
            rawUpdates: rawUpdates
          }, "retrieved raw updates from redis");
          return UpdatesManager.compressAndSaveRawUpdates(project_id, doc_id, rawUpdates, temporary, function(error) {
            if (error != null) {
              return callback(error);
            }
            logger.log({
              project_id: project_id,
              doc_id: doc_id
            }, "compressed and saved doc updates");
            return RedisManager.deleteAppliedDocUpdates(project_id, doc_id, docUpdates, function(error) {
              if (error != null) {
                return callback(error);
              }
              if (length === UpdatesManager.REDIS_READ_BATCH_SIZE) {
                logger.log({
                  project_id: project_id,
                  doc_id: doc_id
                }, "continuing processing updates");
                return setTimeout(function() {
                  return UpdatesManager.processUncompressedUpdates(project_id, doc_id, temporary, callback);
                }, 0);
              } else {
                logger.log({
                  project_id: project_id,
                  doc_id: doc_id
                }, "all raw updates processed");
                return callback();
              }
            });
          });
        });
      });
    },
    processUncompressedUpdatesWithLock: function(project_id, doc_id, callback) {
      if (callback == null) {
        callback = function(error) {};
      }
      return UpdatesManager._prepareProjectForUpdates(project_id, function(error, temporary) {
        if (error != null) {
          return callback(error);
        }
        return UpdatesManager._processUncompressedUpdatesForDocWithLock(project_id, doc_id, temporary, callback);
      });
    },
    _processUncompressedUpdatesForDocWithLock: function(project_id, doc_id, temporary, callback) {
      if (callback == null) {
        callback = function(error) {};
      }
      return UpdatesManager._prepareDocForUpdates(project_id, doc_id, function(error) {
        if (error != null) {
          return callback(error);
        }
        return LockManager.runWithLock(keys.historyLock({
          doc_id: doc_id
        }), function(releaseLock) {
          return UpdatesManager.processUncompressedUpdates(project_id, doc_id, temporary, releaseLock);
        }, callback);
      });
    },
    processUncompressedUpdatesForProject: function(project_id, callback) {
      if (callback == null) {
        callback = function(error) {};
      }
      return RedisManager.getDocIdsWithHistoryOps(project_id, function(error, doc_ids) {
        if (error != null) {
          return callback(error);
        }
        return UpdatesManager._prepareProjectForUpdates(project_id, function(error, temporary) {
          var doc_id, fn, j, jobs, len;
          jobs = [];
          fn = function(doc_id) {
            return jobs.push(function(cb) {
              return UpdatesManager._processUncompressedUpdatesForDocWithLock(project_id, doc_id, temporary, cb);
            });
          };
          for (j = 0, len = doc_ids.length; j < len; j++) {
            doc_id = doc_ids[j];
            fn(doc_id);
          }
          return async.parallelLimit(jobs, 5, callback);
        });
      });
    },
    flushAll: function(limit, callback) {
      if (callback == null) {
        callback = function(error, result) {};
      }
      return RedisManager.getProjectIdsWithHistoryOps(function(error, project_ids) {
        var fn, j, jobs, len, project_id, selectedProjects;
        if (error != null) {
          return callback(error);
        }
        logger.log({
          count: project_ids != null ? project_ids.length : void 0,
          project_ids: project_ids
        }, "found projects");
        jobs = [];
        project_ids = _.shuffle(project_ids);
        selectedProjects = limit < 0 ? project_ids : project_ids.slice(0, limit);
        fn = function(project_id) {
          return jobs.push(function(cb) {
            return UpdatesManager.processUncompressedUpdatesForProject(project_id, function(err) {
              return cb(null, {
                failed: err != null,
                project_id: project_id
              });
            });
          });
        };
        for (j = 0, len = selectedProjects.length; j < len; j++) {
          project_id = selectedProjects[j];
          fn(project_id);
        }
        return async.series(jobs, function(error, result) {
          var failedProjects, succeededProjects, x;
          if (error != null) {
            return callback(error);
          }
          failedProjects = (function() {
            var k, len1, results1;
            results1 = [];
            for (k = 0, len1 = result.length; k < len1; k++) {
              x = result[k];
              if (x.failed) {
                results1.push(x.project_id);
              }
            }
            return results1;
          })();
          succeededProjects = (function() {
            var k, len1, results1;
            results1 = [];
            for (k = 0, len1 = result.length; k < len1; k++) {
              x = result[k];
              if (!x.failed) {
                results1.push(x.project_id);
              }
            }
            return results1;
          })();
          return callback(null, {
            failed: failedProjects,
            succeeded: succeededProjects,
            all: project_ids
          });
        });
      });
    },
    getDanglingUpdates: function(callback) {
      if (callback == null) {
        callback = function(error, doc_ids) {};
      }
      return RedisManager.getAllDocIdsWithHistoryOps(function(error, all_doc_ids) {
        if (error != null) {
          return callback(error);
        }
        return RedisManager.getProjectIdsWithHistoryOps(function(error, all_project_ids) {
          var task;
          if (error != null) {
            return callback(error);
          }
          task = function(cb) {
            return async.concatSeries(all_project_ids, RedisManager.getDocIdsWithHistoryOps, cb);
          };
          return task(function(error, project_doc_ids) {
            var dangling_doc_ids;
            dangling_doc_ids = _.difference(all_doc_ids, project_doc_ids);
            logger.log({
              all_doc_ids: all_doc_ids,
              all_project_ids: all_project_ids,
              project_doc_ids: project_doc_ids,
              dangling_doc_ids: dangling_doc_ids
            }, "checking for dangling doc ids");
            return callback(null, dangling_doc_ids);
          });
        });
      });
    },
    getDocUpdates: function(project_id, doc_id, options, callback) {
      if (options == null) {
        options = {};
      }
      if (callback == null) {
        callback = function(error, updates) {};
      }
      return UpdatesManager.processUncompressedUpdatesWithLock(project_id, doc_id, function(error) {
        if (error != null) {
          return callback(error);
        }
        return PackManager.getOpsByVersionRange(project_id, doc_id, options.from, options.to, function(error, updates) {
          if (error != null) {
            return callback(error);
          }
          return callback(null, updates);
        });
      });
    },
    getDocUpdatesWithUserInfo: function(project_id, doc_id, options, callback) {
      if (options == null) {
        options = {};
      }
      if (callback == null) {
        callback = function(error, updates) {};
      }
      return UpdatesManager.getDocUpdates(project_id, doc_id, options, function(error, updates) {
        if (error != null) {
          return callback(error);
        }
        return UpdatesManager.fillUserInfo(updates, function(error, updates) {
          if (error != null) {
            return callback(error);
          }
          return callback(null, updates);
        });
      });
    },
    getSummarizedProjectUpdates: function(project_id, options, callback) {
      var before, nextBeforeTimestamp, summarizedUpdates;
      if (options == null) {
        options = {};
      }
      if (callback == null) {
        callback = function(error, updates) {};
      }
      options.min_count || (options.min_count = 25);
      summarizedUpdates = [];
      before = options.before;
      nextBeforeTimestamp = null;
      return UpdatesManager.processUncompressedUpdatesForProject(project_id, function(error) {
        if (error != null) {
          return callback(error);
        }
        return PackManager.makeProjectIterator(project_id, before, function(err, iterator) {
          if (err != null) {
            return callback(err);
          }
          return async.whilst(function() {
            return summarizedUpdates.length < options.min_count && !iterator.done();
          }, function(cb) {
            return iterator.next(function(err, partialUpdates) {
              if (err != null) {
                return callback(err);
              }
              if (partialUpdates.length === 0) {
                return cb();
              }
              nextBeforeTimestamp = partialUpdates[partialUpdates.length - 1].meta.end_ts;
              summarizedUpdates = UpdatesManager._summarizeUpdates(partialUpdates, summarizedUpdates);
              return cb();
            });
          }, function() {
            return UpdatesManager.fillSummarizedUserInfo(summarizedUpdates, function(err, results) {
              if (err != null) {
                return callback(err);
              }
              return callback(null, results, !iterator.done() ? nextBeforeTimestamp : void 0);
            });
          });
        });
      });
    },
    fetchUserInfo: function(users, callback) {
      var fetchedUserInfo, fn, jobs, user_id;
      if (callback == null) {
        callback = function(error, fetchedUserInfo) {};
      }
      jobs = [];
      fetchedUserInfo = {};
      fn = function(user_id) {
        return jobs.push(function(callback) {
          return WebApiManager.getUserInfo(user_id, function(error, userInfo) {
            if (error != null) {
              return callback(error);
            }
            fetchedUserInfo[user_id] = userInfo;
            return callback();
          });
        });
      };
      for (user_id in users) {
        fn(user_id);
      }
      return async.series(jobs, function(err) {
        if (err != null) {
          return callback(err);
        }
        return callback(null, fetchedUserInfo);
      });
    },
    fillUserInfo: function(updates, callback) {
      var j, len, update, user_id, users;
      if (callback == null) {
        callback = function(error, updates) {};
      }
      users = {};
      for (j = 0, len = updates.length; j < len; j++) {
        update = updates[j];
        user_id = update.meta.user_id;
        if (UpdatesManager._validUserId(user_id)) {
          users[user_id] = true;
        }
      }
      return UpdatesManager.fetchUserInfo(users, function(error, fetchedUserInfo) {
        var k, len1;
        if (error != null) {
          return callback(error);
        }
        for (k = 0, len1 = updates.length; k < len1; k++) {
          update = updates[k];
          user_id = update.meta.user_id;
          delete update.meta.user_id;
          if (UpdatesManager._validUserId(user_id)) {
            update.meta.user = fetchedUserInfo[user_id];
          }
        }
        return callback(null, updates);
      });
    },
    fillSummarizedUserInfo: function(updates, callback) {
      var j, k, len, len1, update, user_id, user_ids, users;
      if (callback == null) {
        callback = function(error, updates) {};
      }
      users = {};
      for (j = 0, len = updates.length; j < len; j++) {
        update = updates[j];
        user_ids = update.meta.user_ids || [];
        for (k = 0, len1 = user_ids.length; k < len1; k++) {
          user_id = user_ids[k];
          if (UpdatesManager._validUserId(user_id)) {
            users[user_id] = true;
          }
        }
      }
      return UpdatesManager.fetchUserInfo(users, function(error, fetchedUserInfo) {
        var l, len2, len3, m;
        if (error != null) {
          return callback(error);
        }
        for (l = 0, len2 = updates.length; l < len2; l++) {
          update = updates[l];
          user_ids = update.meta.user_ids || [];
          update.meta.users = [];
          delete update.meta.user_ids;
          for (m = 0, len3 = user_ids.length; m < len3; m++) {
            user_id = user_ids[m];
            if (UpdatesManager._validUserId(user_id)) {
              update.meta.users.push(fetchedUserInfo[user_id]);
            } else {
              update.meta.users.push(null);
            }
          }
        }
        return callback(null, updates);
      });
    },
    _validUserId: function(user_id) {
      if (user_id == null) {
        return false;
      } else {
        return !!user_id.match(/^[a-f0-9]{24}$/);
      }
    },
    TIME_BETWEEN_DISTINCT_UPDATES: fiveMinutes = 5 * 60 * 1000,
    SPLIT_ON_DELETE_SIZE: 16,
    _summarizeUpdates: function(updates, existingSummarizedUpdates) {
      var doc, doc_id, earliestUpdate, isBigDelete, j, k, len, len1, newUpdate, op, previousUpdateWasBigDelete, ref, shouldConcat, summarizedUpdates, update;
      if (existingSummarizedUpdates == null) {
        existingSummarizedUpdates = [];
      }
      summarizedUpdates = existingSummarizedUpdates.slice();
      previousUpdateWasBigDelete = false;
      for (j = 0, len = updates.length; j < len; j++) {
        update = updates[j];
        earliestUpdate = summarizedUpdates[summarizedUpdates.length - 1];
        shouldConcat = false;
        if (previousUpdateWasBigDelete) {
          shouldConcat = false;
        } else if (earliestUpdate && earliestUpdate.meta.end_ts - update.meta.start_ts < this.TIME_BETWEEN_DISTINCT_UPDATES) {
          shouldConcat = true;
        }
        isBigDelete = false;
        ref = update.op || [];
        for (k = 0, len1 = ref.length; k < len1; k++) {
          op = ref[k];
          if ((op.d != null) && op.d.length > this.SPLIT_ON_DELETE_SIZE) {
            isBigDelete = true;
          }
        }
        previousUpdateWasBigDelete = isBigDelete;
        if (shouldConcat) {
          earliestUpdate.meta.user_ids = _.union(earliestUpdate.meta.user_ids, [update.meta.user_id]);
          doc_id = update.doc_id.toString();
          doc = earliestUpdate.docs[doc_id];
          if (doc != null) {
            doc.fromV = Math.min(doc.fromV, update.v);
            doc.toV = Math.max(doc.toV, update.v);
          } else {
            earliestUpdate.docs[doc_id] = {
              fromV: update.v,
              toV: update.v
            };
          }
          earliestUpdate.meta.start_ts = Math.min(earliestUpdate.meta.start_ts, update.meta.start_ts);
          earliestUpdate.meta.end_ts = Math.max(earliestUpdate.meta.end_ts, update.meta.end_ts);
        } else {
          newUpdate = {
            meta: {
              user_ids: [],
              start_ts: update.meta.start_ts,
              end_ts: update.meta.end_ts
            },
            docs: {}
          };
          newUpdate.docs[update.doc_id.toString()] = {
            fromV: update.v,
            toV: update.v
          };
          newUpdate.meta.user_ids.push(update.meta.user_id);
          summarizedUpdates.push(newUpdate);
        }
      }
      return summarizedUpdates;
    }
  };

}).call(this);

//# sourceMappingURL=UpdatesManager.js.map
