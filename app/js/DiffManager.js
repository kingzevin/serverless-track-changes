// Generated by CoffeeScript 1.12.4
(function() {
  var DiffGenerator, DiffManager, DocumentUpdaterManager, UpdatesManager, logger,
    slice = [].slice;

  UpdatesManager = require("./UpdatesManager");

  DocumentUpdaterManager = require("./DocumentUpdaterManager");

  DiffGenerator = require("./DiffGenerator");

  logger = require("logger-sharelatex");

  module.exports = DiffManager = {
    getLatestDocAndUpdates: function(project_id, doc_id, fromVersion, callback) {
      if (callback == null) {
        callback = function(error, content, version, updates) {};
      }
      return DocumentUpdaterManager.getDocument(project_id, doc_id, function(error, content, version) {
        if (error != null) {
          return callback(error);
        }
        if (fromVersion == null) {
          return callback(null, content, version, []);
        }
        return UpdatesManager.getDocUpdatesWithUserInfo(project_id, doc_id, {
          from: fromVersion
        }, function(error, updates) {
          if (error != null) {
            return callback(error);
          }
          return callback(null, content, version, updates);
        });
      });
    },
    getDiff: function(project_id, doc_id, fromVersion, toVersion, callback) {
      if (callback == null) {
        callback = function(error, diff) {};
      }
      return DiffManager.getDocumentBeforeVersion(project_id, doc_id, fromVersion, function(error, startingContent, updates) {
        var diff, e, i, len, ref, update, updatesToApply;
        if (error != null) {
          if (error.message === "broken-history") {
            return callback(null, "history unavailable");
          } else {
            return callback(error);
          }
        }
        updatesToApply = [];
        ref = updates.slice().reverse();
        for (i = 0, len = ref.length; i < len; i++) {
          update = ref[i];
          if (update.v <= toVersion) {
            updatesToApply.push(update);
          }
        }
        try {
          diff = DiffGenerator.buildDiff(startingContent, updatesToApply);
        } catch (error1) {
          e = error1;
          return callback(e);
        }
        return callback(null, diff);
      });
    },
    getDocumentBeforeVersion: function(project_id, doc_id, version, _callback) {
      var callback, retries, retry;
      if (_callback == null) {
        _callback = function(error, document, rewoundUpdates) {};
      }
      retries = 3;
      callback = function() {
        var args, error;
        error = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
        if (error != null) {
          if (error.retry && retries > 0) {
            logger.warn({
              error: error,
              project_id: project_id,
              doc_id: doc_id,
              version: version,
              retries: retries
            }, "retrying getDocumentBeforeVersion");
            return retry();
          } else {
            return _callback(error);
          }
        } else {
          return _callback.apply(null, [null].concat(slice.call(args)));
        }
      };
      return (retry = function() {
        retries--;
        return DiffManager._tryGetDocumentBeforeVersion(project_id, doc_id, version, callback);
      })();
    },
    _tryGetDocumentBeforeVersion: function(project_id, doc_id, version, callback) {
      if (callback == null) {
        callback = function(error, document, rewoundUpdates) {};
      }
      logger.log({
        project_id: project_id,
        doc_id: doc_id,
        version: version
      }, "getting document before version");
      return DiffManager.getLatestDocAndUpdates(project_id, doc_id, version, function(error, content, version, updates) {
        var e, i, lastUpdate, len, ref, startingContent, tryUpdates, u;
        if (error != null) {
          return callback(error);
        }
        for (i = 0, len = updates.length; i < len; i++) {
          u = updates[i];
          if (u.broken) {
            return callback(new Error("broken-history"));
          }
        }
        while (((ref = updates[0]) != null ? ref.v : void 0) >= version) {
          updates.shift();
        }
        lastUpdate = updates[0];
        if ((lastUpdate != null) && lastUpdate.v !== version - 1) {
          error = new Error("latest update version, " + lastUpdate.v + ", does not match doc version, " + version);
          error.retry = true;
          return callback(error);
        }
        logger.log({
          docVersion: version,
          lastUpdateVersion: lastUpdate != null ? lastUpdate.v : void 0,
          updateCount: updates.length
        }, "rewinding updates");
        tryUpdates = updates.slice().reverse();
        try {
          startingContent = DiffGenerator.rewindUpdates(content, tryUpdates);
        } catch (error1) {
          e = error1;
          return callback(e);
        }
        return callback(null, startingContent, tryUpdates);
      });
    }
  };

}).call(this);

//# sourceMappingURL=DiffManager.js.map
