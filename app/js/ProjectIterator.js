// Generated by CoffeeScript 1.12.4
(function() {
  var Heap, ProjectIterator;

  Heap = require("heap");

  module.exports = ProjectIterator = ProjectIterator = (function() {
    function ProjectIterator(packs, before1, getPackByIdFn) {
      var byEndTs;
      this.before = before1;
      this.getPackByIdFn = getPackByIdFn;
      byEndTs = function(a, b) {
        return (b.meta.end_ts - a.meta.end_ts) || (a.fromIndex - b.fromIndex);
      };
      this.packs = packs.slice().sort(byEndTs);
      this.queue = new Heap(byEndTs);
    }

    ProjectIterator.prototype.next = function(callback) {
      var before, iterator, lowWaterMark, nextItem, nextPack, opsToReturn, queue;
      iterator = this;
      before = this.before;
      queue = iterator.queue;
      opsToReturn = [];
      nextPack = iterator.packs[0];
      lowWaterMark = (nextPack != null ? nextPack.meta.end_ts : void 0) || 0;
      nextItem = queue.peek();
      while ((before != null) && (nextPack != null ? nextPack.meta.start_ts : void 0) > before) {
        iterator.packs.shift();
        nextPack = iterator.packs[0];
        lowWaterMark = (nextPack != null ? nextPack.meta.end_ts : void 0) || 0;
      }
      if ((queue.empty() || (nextItem != null ? nextItem.meta.end_ts : void 0) <= lowWaterMark) && (nextPack != null)) {
        return this.getPackByIdFn(nextPack.project_id, nextPack.doc_id, nextPack._id, function(err, pack) {
          var i, len, op, ref;
          if (err != null) {
            return callback(err);
          }
          iterator.packs.shift();
          ref = pack.pack;
          for (i = 0, len = ref.length; i < len; i++) {
            op = ref[i];
            if (!((before == null) || op.meta.end_ts < before)) {
              continue;
            }
            op.doc_id = nextPack.doc_id;
            op.project_id = nextPack.project_id;
            queue.push(op);
          }
          return iterator.next(callback);
        });
      }
      while ((nextItem != null) && ((nextItem != null ? nextItem.meta.end_ts : void 0) > lowWaterMark)) {
        opsToReturn.push(nextItem);
        queue.pop();
        nextItem = queue.peek();
      }
      if (queue.empty() && (nextPack == null)) {
        iterator._done = true;
      }
      return callback(null, opsToReturn);
    };

    ProjectIterator.prototype.done = function() {
      return this._done;
    };

    return ProjectIterator;

  })();

}).call(this);

//# sourceMappingURL=ProjectIterator.js.map
