// Generated by CoffeeScript 1.12.4
(function() {
  var COUNT, HOST, LockManager, PID, RND, Settings, crypto, logger, os, rclient, redis;

  Settings = require("settings-sharelatex");

  redis = require("redis-sharelatex");

  rclient = redis.createClient(Settings.redis.lock);

  os = require("os");

  crypto = require("crypto");

  logger = require("logger-sharelatex");

  HOST = os.hostname();

  PID = process.pid;

  RND = crypto.randomBytes(4).toString('hex');

  COUNT = 0;

  module.exports = LockManager = {
    LOCK_TEST_INTERVAL: 50,
    MAX_LOCK_WAIT_TIME: 10000,
    LOCK_TTL: 300,
    randomLock: function() {
      var time;
      time = Date.now();
      return "locked:host=" + HOST + ":pid=" + PID + ":random=" + RND + ":time=" + time + ":count=" + (COUNT++);
    },
    unlockScript: 'if redis.call("get", KEYS[1]) == ARGV[1] then return redis.call("del", KEYS[1]) else return 0 end',
    tryLock: function(key, callback) {
      var lockValue;
      if (callback == null) {
        callback = function(err, gotLock) {};
      }
      lockValue = LockManager.randomLock();
      return rclient.set(key, lockValue, "EX", this.LOCK_TTL, "NX", function(err, gotLock) {
        if (err != null) {
          return callback(err);
        }
        if (gotLock === "OK") {
          return callback(err, true, lockValue);
        } else {
          return callback(err, false);
        }
      });
    },
    getLock: function(key, callback) {
      var attempt, startTime;
      if (callback == null) {
        callback = function(error) {};
      }
      startTime = Date.now();
      return (attempt = function() {
        var e;
        if (Date.now() - startTime > LockManager.MAX_LOCK_WAIT_TIME) {
          e = new Error("Timeout");
          e.key = key;
          return callback(e);
        }
        return LockManager.tryLock(key, function(error, gotLock, lockValue) {
          if (error != null) {
            return callback(error);
          }
          if (gotLock) {
            return callback(null, lockValue);
          } else {
            return setTimeout(attempt, LockManager.LOCK_TEST_INTERVAL);
          }
        });
      })();
    },
    checkLock: function(key, callback) {
      if (callback == null) {
        callback = function(err, isFree) {};
      }
      return rclient.exists(key, function(err, exists) {
        if (err != null) {
          return callback(err);
        }
        exists = parseInt(exists);
        if (exists === 1) {
          return callback(err, false);
        } else {
          return callback(err, true);
        }
      });
    },
    releaseLock: function(key, lockValue, callback) {
      return rclient["eval"](LockManager.unlockScript, 1, key, lockValue, function(err, result) {
        if (err != null) {
          return callback(err);
        }
        if ((result != null) && result !== 1) {
          logger.error({
            key: key,
            lockValue: lockValue,
            redis_err: err,
            redis_result: result
          }, "unlocking error");
          return callback(new Error("tried to release timed out lock"));
        }
        return callback(err, result);
      });
    },
    runWithLock: function(key, runner, callback) {
      if (runner == null) {
        runner = (function(releaseLock) {
          if (releaseLock == null) {
            releaseLock = function(error) {};
          }
        });
      }
      if (callback == null) {
        callback = (function(error) {});
      }
      return LockManager.getLock(key, function(error, lockValue) {
        if (error != null) {
          return callback(error);
        }
        return runner(function(error1) {
          return LockManager.releaseLock(key, lockValue, function(error2) {
            error = error1 || error2;
            if (error != null) {
              return callback(error);
            }
            return callback();
          });
        });
      });
    },
    healthCheck: function(callback) {
      var action;
      action = function(releaseLock) {
        return releaseLock();
      };
      return LockManager.runWithLock("HistoryLock:HealthCheck:host=" + HOST + ":pid=" + PID + ":random=" + RND, action, callback);
    },
    close: function(callback) {
      rclient.quit();
      return rclient.once('end', callback);
    }
  };

}).call(this);

//# sourceMappingURL=LockManager.js.map
