// Generated by CoffeeScript 1.12.4
(function() {
  var ConsistencyError, DiffGenerator, logger;

  ConsistencyError = function(message) {
    var error;
    error = new Error(message);
    error.name = "ConsistencyError";
    error.__proto__ = ConsistencyError.prototype;
    return error;
  };

  ConsistencyError.prototype.__proto__ = Error.prototype;

  logger = require("logger-sharelatex");

  module.exports = DiffGenerator = {
    ConsistencyError: ConsistencyError,
    rewindUpdate: function(content, update) {
      var e, i, j, op, ref;
      ref = update.op;
      for (i = j = ref.length - 1; j >= 0; i = j += -1) {
        op = ref[i];
        if (op.broken !== true) {
          try {
            content = DiffGenerator.rewindOp(content, op);
          } catch (error1) {
            e = error1;
            if (e instanceof ConsistencyError && (i = update.op.length - 1)) {
              logger.error({
                err: e,
                update: update,
                op: JSON.stringify(op)
              }, "marking op as broken");
              op.broken = true;
            } else {
              throw e;
            }
          }
        }
      }
      return content;
    },
    rewindOp: function(content, op) {
      var max_p, p, textToBeRemoved;
      if (op.i != null) {
        p = op.p;
        max_p = content.length - op.i.length;
        if (p > max_p) {
          logger.warn({
            max_p: max_p,
            p: p
          }, "truncating position to content length");
          p = max_p;
        }
        textToBeRemoved = content.slice(p, p + op.i.length);
        if (op.i !== textToBeRemoved) {
          throw new ConsistencyError("Inserted content, '" + op.i + "', does not match text to be removed, '" + textToBeRemoved + "'");
        }
        return content.slice(0, p) + content.slice(p + op.i.length);
      } else if (op.d != null) {
        return content.slice(0, op.p) + op.d + content.slice(op.p);
      } else {
        return content;
      }
    },
    rewindUpdates: function(content, updates) {
      var e, j, len, ref, update;
      ref = updates.reverse();
      for (j = 0, len = ref.length; j < len; j++) {
        update = ref[j];
        try {
          content = DiffGenerator.rewindUpdate(content, update);
        } catch (error1) {
          e = error1;
          e.attempted_update = update;
          throw e;
        }
      }
      return content;
    },
    buildDiff: function(initialContent, updates) {
      var diff, j, len, update;
      diff = [
        {
          u: initialContent
        }
      ];
      for (j = 0, len = updates.length; j < len; j++) {
        update = updates[j];
        diff = DiffGenerator.applyUpdateToDiff(diff, update);
      }
      diff = DiffGenerator.compressDiff(diff);
      return diff;
    },
    compressDiff: function(diff) {
      var j, lastPart, len, newDiff, part, ref, ref1;
      newDiff = [];
      for (j = 0, len = diff.length; j < len; j++) {
        part = diff[j];
        lastPart = newDiff[newDiff.length - 1];
        if ((lastPart != null) && (((ref = lastPart.meta) != null ? ref.user : void 0) != null) && (((ref1 = part.meta) != null ? ref1.user : void 0) != null)) {
          if ((lastPart.i != null) && (part.i != null) && lastPart.meta.user.id === part.meta.user.id) {
            lastPart.i += part.i;
            lastPart.meta.start_ts = Math.min(lastPart.meta.start_ts, part.meta.start_ts);
            lastPart.meta.end_ts = Math.max(lastPart.meta.end_ts, part.meta.end_ts);
          } else if ((lastPart.d != null) && (part.d != null) && lastPart.meta.user.id === part.meta.user.id) {
            lastPart.d += part.d;
            lastPart.meta.start_ts = Math.min(lastPart.meta.start_ts, part.meta.start_ts);
            lastPart.meta.end_ts = Math.max(lastPart.meta.end_ts, part.meta.end_ts);
          } else {
            newDiff.push(part);
          }
        } else {
          newDiff.push(part);
        }
      }
      return newDiff;
    },
    applyOpToDiff: function(diff, op, meta) {
      var consumedDiff, newDiff, position, ref, ref1, remainingDiff;
      position = 0;
      remainingDiff = diff.slice();
      ref = DiffGenerator._consumeToOffset(remainingDiff, op.p), consumedDiff = ref.consumedDiff, remainingDiff = ref.remainingDiff;
      newDiff = consumedDiff;
      if (op.i != null) {
        newDiff.push({
          i: op.i,
          meta: meta
        });
      } else if (op.d != null) {
        ref1 = DiffGenerator._consumeDiffAffectedByDeleteOp(remainingDiff, op, meta), consumedDiff = ref1.consumedDiff, remainingDiff = ref1.remainingDiff;
        newDiff.push.apply(newDiff, consumedDiff);
      }
      newDiff.push.apply(newDiff, remainingDiff);
      return newDiff;
    },
    applyUpdateToDiff: function(diff, update) {
      var j, len, op, ref;
      ref = update.op;
      for (j = 0, len = ref.length; j < len; j++) {
        op = ref[j];
        if (op.broken !== true) {
          diff = DiffGenerator.applyOpToDiff(diff, op, update.meta);
        }
      }
      return diff;
    },
    _consumeToOffset: function(remainingDiff, totalOffset) {
      var consumedDiff, length, part, partOffset, position;
      consumedDiff = [];
      position = 0;
      while (part = remainingDiff.shift()) {
        length = DiffGenerator._getLengthOfDiffPart(part);
        if (part.d != null) {
          consumedDiff.push(part);
        } else if (position + length >= totalOffset) {
          partOffset = totalOffset - position;
          if (partOffset > 0) {
            consumedDiff.push(DiffGenerator._slicePart(part, 0, partOffset));
          }
          if (partOffset < length) {
            remainingDiff.unshift(DiffGenerator._slicePart(part, partOffset));
          }
          break;
        } else {
          position += length;
          consumedDiff.push(part);
        }
      }
      return {
        consumedDiff: consumedDiff,
        remainingDiff: remainingDiff
      };
    },
    _consumeDiffAffectedByDeleteOp: function(remainingDiff, deleteOp, meta) {
      var consumedDiff, newPart, ref, remainingOp;
      consumedDiff = [];
      remainingOp = deleteOp;
      while (remainingOp && remainingDiff.length > 0) {
        ref = DiffGenerator._consumeDeletedPart(remainingDiff, remainingOp, meta), newPart = ref.newPart, remainingDiff = ref.remainingDiff, remainingOp = ref.remainingOp;
        if (newPart != null) {
          consumedDiff.push(newPart);
        }
      }
      return {
        consumedDiff: consumedDiff,
        remainingDiff: remainingDiff
      };
    },
    _consumeDeletedPart: function(remainingDiff, op, meta) {
      var deletedContent, newPart, opContent, part, partLength, remainingOp, remainingPart;
      part = remainingDiff.shift();
      partLength = DiffGenerator._getLengthOfDiffPart(part);
      if (part.d != null) {
        remainingOp = op;
        newPart = part;
      } else if (partLength > op.d.length) {
        remainingPart = DiffGenerator._slicePart(part, op.d.length);
        remainingDiff.unshift(remainingPart);
        deletedContent = DiffGenerator._getContentOfPart(part).slice(0, op.d.length);
        if (deletedContent !== op.d) {
          throw new ConsistencyError("deleted content, '" + deletedContent + "', does not match delete op, '" + op.d + "'");
        }
        if (part.u != null) {
          newPart = {
            d: op.d,
            meta: meta
          };
        } else if (part.i != null) {
          newPart = null;
        }
        remainingOp = null;
      } else if (partLength === op.d.length) {
        deletedContent = DiffGenerator._getContentOfPart(part);
        if (deletedContent !== op.d) {
          throw new ConsistencyError("deleted content, '" + deletedContent + "', does not match delete op, '" + op.d + "'");
        }
        if (part.u != null) {
          newPart = {
            d: op.d,
            meta: meta
          };
        } else if (part.i != null) {
          newPart = null;
        }
        remainingOp = null;
      } else if (partLength < op.d.length) {
        deletedContent = DiffGenerator._getContentOfPart(part);
        opContent = op.d.slice(0, deletedContent.length);
        if (deletedContent !== opContent) {
          throw new ConsistencyError("deleted content, '" + deletedContent + "', does not match delete op, '" + opContent + "'");
        }
        if (part.u) {
          newPart = {
            d: part.u,
            meta: meta
          };
        } else if (part.i != null) {
          newPart = null;
        }
        remainingOp = {
          p: op.p,
          d: op.d.slice(DiffGenerator._getLengthOfDiffPart(part))
        };
      }
      return {
        newPart: newPart,
        remainingDiff: remainingDiff,
        remainingOp: remainingOp
      };
    },
    _slicePart: function(basePart, from, to) {
      var part;
      if (basePart.u != null) {
        part = {
          u: basePart.u.slice(from, to)
        };
      } else if (basePart.i != null) {
        part = {
          i: basePart.i.slice(from, to)
        };
      }
      if (basePart.meta != null) {
        part.meta = basePart.meta;
      }
      return part;
    },
    _getLengthOfDiffPart: function(part) {
      return (part.u || part.d || part.i || '').length;
    },
    _getContentOfPart: function(part) {
      return part.u || part.d || part.i || '';
    }
  };

}).call(this);

//# sourceMappingURL=DiffGenerator.js.map
